\ProvidesPackage{local-macros}

%\RequirePackage{mathtools}
%\RequirePackage{xparse}
%\RequirePackage{pgffor}
%\RequirePackage{ifthen}
%\RequirePackage{amssymb}
%\RequirePackage{xspace}
% \RequirePackage{colonequals}

%basic symbols maths
\newcommand{\Real}{{\mathbb R}}
%\newcommand{\terms}{{\mathcal{T}}}
\newcommand{\domainSymbol}{{\mathcal{D}}}


%cosmetic
%\newcommand{\natalia}[1]{\marginpar{\textcolor{blue}{Natalia: #1}}}

%loss
\newcommand{\losssymbol}{\mathcal{L}}
\newcommand{\lossfn}{\losssymbol}
\newcommand{\lossfnc}{\losssymbol_C}
\newcommand{\lossfncc}{\hat{\losssymbol}}
\newcommand{\loss}[1]{\lossfn(#1)}
\newcommand{\lossc}[1]{\lossfnc(#1)}
\newcommand{\losscc}[1]{\lossfncc(#1)}

%logic
\newcommand{\conjM}{\bigwedge\nolimits_M}
\newcommand{\conj}[1]{\bigwedge\nolimits_{#1}}
\newcommand{\disjM}{\bigvee\nolimits_M}
\newcommand{\disj}[1]{\bigvee\nolimits_{#1}}


%translations
\newcommand{\tDLtwo}[1]{\llbracket #1 \rrbracket_{DL2}}
\newcommand{\tfuzzy}[1]{\llbracket #1 \rrbracket_G}
\newcommand{\tSTL}[1]{\llbracket #1 \rrbracket_{S}}
\newcommand{\tlukasiewicz}[1]{\llbracket #1 \rrbracket_{L}}
\newcommand{\tyager}[1]{\llbracket #1 \rrbracket_{Y}}
\newcommand{\tproduct}[1]{\llbracket #1 \rrbracket_{P}}
\newcommand{\tempty}[1]{\llbracket #1 \rrbracket}
\newcommand{\tbig}[1]{\bigg\llbracket #1 \bigg\rrbracket}
\newcommand{\tnew}[1]{\llbracket #1 \rrbracket_{new}}
\newcommand{\context}[1]{^{#1}}

%sytntax sugar
%\newcommand{\lam}[2]{\ #1,\ #2\ .}
\newcommand{\lam}[1]{\lambda #1\ .}


%input output
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\x}{\vect{x}} % Arbitrary input
\newcommand{\xt}{\hat{\x}} % Training input
\newcommand{\y}{\vect{y}} % Output
\newcommand{\z}{\vect{z}} % Output
\newcommand{\Dc}{\mathcal{D}_C}



% Use a new style for remarks
\theoremstyle{remark}
\newtheorem*{rmk}{Remark}

\newcommand{\dltwo}{DL$2$}
\usepackage[font=footnotesize,labelfont=it]{caption}

%Matthew's - need to go through and swap some stuff, rename some
\newcommand{\bool}{\mathbb{B}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\id}{v}
\newcommand{\val}{a}
\newcommand{\cons}[2]{#1 :: #2}

% High-level language

\newcommand{\FunType}[2]{\ensuremath{#1 \text{ $ \rightarrow $ } #2}}
\newcommand{\VecType}[1]{\ensuremath{\text{Vec } #1}}
\newcommand{\FinType}[1]{\ensuremath{\text{Fin } #1}}
\newcommand{\BoolType}{\ensuremath{\text{Bool}}}
\newcommand{\RealType}{\ensuremath{\text{Real}}}

\newcommand{\IfSymbol}{ite}
\newcommand{\AtSymbol}{!}
\newcommand{\AndSymbol}{\wedge }
\newcommand{\OrSymbol}{$ \vee $}
\newcommand{\NotSymbol}{$ \neg $}
\newcommand{\AddSymbol}{+}
\newcommand{\MulSymbol}{$ \times $}
\newcommand{\EqSymbol}{==}
\newcommand{\NeqSymbol}{$ \neq $}
\newcommand{\LeqSymbol}{$ \leq $}
\newcommand{\GeqSymbol}{$ \geq $}
\newcommand{\LeSymbol}{$ < $}
\newcommand{\GeSymbol}{$ > $}

\newcommand{\App}[2]{\ensuremath{#1 \: #2}}
\newcommand{\Lam}[3]{\ensuremath{\text{lam } (#1 : #2) \text{ . } #3}}
\newcommand{\Let}[4]{\ensuremath{\text{let } (#1 : #2) = #3 \text{ in } #4}}
\newcommand{\Forall}[3]{\ensuremath{\text{forall } (#1 : #2) \text{ . } #3}}
\newcommand{\Exists}[3]{\ensuremath{\text{exists } (#1 : #2) \text{ . } #3}}
\newcommand{\fAnd}[2]{\ensuremath{#1 \text{ \AndSymbol{} } #2}}
\newcommand{\fOr}[2]{\ensuremath{#1 \text{ \OrSymbol{} } #2}}
\newcommand{\fNot}[1]{\ensuremath{\text{\NotSymbol{} } #1}}
\newcommand{\If}[3]{\ensuremath{\text{if } #1 \text{ then } #2 \text{ else } #3}}
\newcommand{\Add}[2]{\ensuremath{#1 \text{ \AddSymbol{} } #2}}
\newcommand{\Mul}[2]{\ensuremath{#1 \text{ \MulSymbol{} } #2}}
\newcommand{\Eq}[2]{\ensuremath{#1 \text{ \EqSymbol{} } #2}}
\newcommand{\Neq}[2]{\ensuremath{#1 \text{ \NeqSymbol{} } #2}}
\newcommand{\Leq}[2]{\ensuremath{#1 \text{ \LeqSymbol{} } #2}}
\newcommand{\Geq}[2]{\ensuremath{#1 \text{ \GeqSymbol{} } #2}}
\newcommand{\Le}[2]{\ensuremath{#1 \text{ \LeSymbol{} } #2}}
\newcommand{\Ge}[2]{\ensuremath{#1 \text{ \GeSymbol{} } #2}}
\newcommand{\Seq}[2]{\ensuremath{[#1, ..., #2]}}
\newcommand{\elReal}{\ensuremath{r}}
\newcommand{\elNat}{\ensuremath{i}}
\newcommand{\elBool}{\ensuremath{b}}
\newcommand{\At}[2]{\ensuremath{#1 \text{ \AtSymbol{} } #2}}
\newcommand{\hLam}[3]{\ensuremath{\text{lam } (#1 : #2) \text{ . } #3}}


% contexts

\newcommand{\polCtx}{P}
\newcommand{\forallPol}{+}
\newcommand{\existsPol}{-}
\newcommand{\hNetCtx}{N}
\newcommand{\hVarCtx}{\Gamma}
\newcommand{\lNetCtx}{M}
\newcommand{\lInputVarCtx}{I}
\newcommand{\lOutputVarCtx}{O}

% types

\newcommand{\hTypeRel}[3]{#1 \vdash #2 : #3}
\newcommand{\hcTypeRel}[2]{\hTypeRel{\hNetCtx,\hVarCtx}{#1}{#2}}
\newcommand{\haTypeRel}{\hcTypeRel{e}{\tau}}

\newcommand{\lTypeRel}[2]{#1 \vdash #2}
\newcommand{\laTypeRel}{\lTypeRel{\lNetCtx}{e}}

%grammar
\newcommand{\grammarItem}[1]{\langle \textit{#1} \, \rangle}
\newcommand{\typeClass}{\grammarItem{type}}
\newcommand{\exprClass}{\grammarItem{expr}}
\newcommand{\opClass}{\grammarItem{op}}
\newcommand{\identClass}{\grammarItem{ident}}

\newcommand{\progClass}{\grammarItem{prog}}
\newcommand{\queryClass}{\grammarItem{query}}
\newcommand{\arithClass}{\grammarItem{arith}}
\newcommand{\compareClass}{\grammarItem{comp}}
\newcommand{\conjClass}{\grammarItem{conj}}
\newcommand{\inputVarClass}{\grammarItem{inputVar}}
\newcommand{\outputVarClass}{\grammarItem{outputVar}}

% semantics

\newcommand{\hSem}[2]{{\llbracket #1 \rrbracket}^{#2}}
\newcommand{\hsSem}[1]{\hSem{#1}{\hVarCtx}}

\newcommand{\lCtxFun}{\gamma}
\newcommand{\lNetCtxSem}[3]{\lSemBraces{#1}^{#2,#3}}

\newcommand{\lSemBraces}[1]{\langle \! \langle #1 \rangle \! \rangle}
\newcommand{\lSem}[2]{{\lSemBraces{#1}}^{#2}}
\newcommand{\lsSem}[1]{\lSem{#1}{}}

\newcommand{\semSpace}{\qquad\qquad}
