\ProvidesPackage{local-macros}

\RequirePackage{mathtools}
\RequirePackage{xparse}
\RequirePackage{pgffor}
\RequirePackage{ifthen}
\RequirePackage{amssymb}
\RequirePackage{xspace}

%basic symbols maths
\newcommand{\Real}{{\mathbb R}}
%\newcommand{\terms}{{\mathcal{T}}}
\newcommand{\domainSymbol}{{\mathcal{D}}}
\newcommand{\distr}{p}
\newcommand{\dataset}{\mathcal{X}}
\newcommand{\hypothesis}{\mathcal{H}}
\newcommand{\property}{\phi}
\newcommand{\logic}{L}

\newcommand{\godel}{G\"{o}del}

%cosmetic
\newcommand{\matthew}[1]{\begin{authorComment}{red!15}Matthew: #1\end{authorComment}}




%loss
\newcommand{\losssymbol}{\mathcal{L}}
\newcommand{\lossfn}{\losssymbol}
\newcommand{\lossfnc}{\losssymbol_C}
\newcommand{\lossfncc}{\hat{\losssymbol}}
\newcommand{\loss}[1]{\lossfn(#1)}
\newcommand{\lossc}[1]{\lossfnc(#1)}
\newcommand{\losscc}[1]{\lossfncc(#1)}

%weights
\newcommand{\ws}{\mathbf{w}}
\newcommand{\translation}{\mathbf{T}}
%logic
\newcommand{\conjM}{\bigwedge\nolimits_M}
\newcommand{\conjL}[1]{\bigwedge\nolimits_{#1}}
\newcommand{\disjM}{\bigvee\nolimits_M}
\newcommand{\disjL}[1]{\bigvee\nolimits_{#1}}


%translations
\newcommand{\tDLtwo}[1]{\llbracket #1 \rrbracket_{DL2}}
\newcommand{\tGodel}[1]{\llbracket #1 \rrbracket_G}
\newcommand{\tSTL}[1]{\llbracket #1 \rrbracket_{S}}
\newcommand{\tlukasiewicz}[1]{\llbracket #1 \rrbracket_{\text{≈Å}}}
\newcommand{\tyager}[1]{\llbracket #1 \rrbracket_{Y}}
\newcommand{\tproduct}[1]{\llbracket #1 \rrbracket_{P}}
\newcommand{\tempty}[1]{\llbracket #1 \rrbracket}
\newcommand{\tbig}[1]{\bigg\llbracket #1 \bigg\rrbracket}
\newcommand{\tnew}[1]{\llbracket #1 \rrbracket_{new}}
\newcommand{\ttype}[1]{\llangle #1 \rrangle}
\newcommand{\texpr}[5]{\tempty{#1}^{#2,#3,#4}_{#5}}


\newcommand{\context}[1]{^{#1}}

%sytntax sugar
%\newcommand{\lam}[2]{\ #1,\ #2\ .}
\newcommand{\lam}[1]{\lambda #1\ .}
\newcommand{\lamText}{\text{lam}}
\newcommand{\letText}{\text{let}}
\newcommand{\forallText}{\text{forall}}
\newcommand{\robustexpr}{e_{robust}}


%input output
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\x}{\vect{x}} % Arbitrary input
\newcommand{\X}{\vect{X}} % Arbitrary input
\newcommand{\Y}{\vect{Y}} % Arbitrary input
\newcommand{\xt}{\hat{\x}} % Training input
\newcommand{\y}{\vect{y}} % Output
\newcommand{\z}{\vect{z}} % Output
\newcommand{\Dc}{\mathcal{D}_C}
\newcommand{\D}{\vect{D}}

%llangle and rrangle but without MnSymbol because of conflicts with oher packages
\newsavebox{\@brx}
\newcommand{\llangle}[1][]{\savebox{\@brx}{\(\m@th{#1\langle}\)}%
	\mathopen{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\newcommand{\rrangle}[1][]{\savebox{\@brx}{\(\m@th{#1\rangle}\)}%
	\mathclose{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}



\newcommand{\dltwo}{DL$2$}
\usepackage[font=footnotesize,labelfont=it]{caption}

%Matthew's - need to go through and swap some stuff, rename some
\newcommand{\Bool}{\mathbb{B}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\id}{x}
\newcommand{\val}{a}
\newcommand{\cons}[2]{#1 :: #2}
\newcommand{\consNew}[2]{#2[#1]}

% High-level language
\newcommand{\FunType}[2]{\ensuremath{#1 \text{ $ \rightarrow $ } #2}}
%\newcommand{\App}[2]{\ensuremath{#1 \text{ $ \rightarrow $ } #2}}
\newcommand{\VecType}[1]{\ensuremath{\text{Vec } #1}}
\newcommand{\FinType}[1]{\ensuremath{\text{Index } #1}}
\newcommand{\BoolType}{\ensuremath{\text{Bool}}}
\newcommand{\RealType}{\ensuremath{\text{Real}}}

\newcommand{\IfSymbol}{ite}
\newcommand{\AtSymbol}{!}

\newcommand{\AndSymbol}{$\wedge $}
\newcommand{\OrSymbol}{$ \vee $}
\newcommand{\NotSymbol}{$ \neg $}
\newcommand{\ImpliesSymbol}{$ \impl $}
\newcommand{\AddSymbol}{+}
\newcommand{\NegSymbol}{-}
\newcommand{\MulSymbol}{$ \times $}
\newcommand{\EqSymbol}{==}
\newcommand{\NeqSymbol}{$ \neq $}
\newcommand{\LeqSymbol}{$ \leq $}
\newcommand{\GeqSymbol}{$ \geq $}
\newcommand{\LeSymbol}{$ < $}
\newcommand{\GeSymbol}{$ > $}

\newcommand{\AndText}{and}
\newcommand{\OrText}{or}
\newcommand{\NotText}{not}
\newcommand{\ImplText}{implies}
\newcommand{\AddText}{add}
\newcommand{\MulText}{mul}
\newcommand{\EqText}{$==$}
\newcommand{\NeqText}{$!=$}
\newcommand{\LeqText}{$<=$}
\newcommand{\GeqText}{$>=$}
\newcommand{\LeText}{$<$}
\newcommand{\GeText}{$ > $}

\newcommand{\App}[2]{\ensuremath{#1 \: #2}}
\newcommand{\Lam}[3]{\ensuremath{\text{lam } (#1 : #2) \text{ . } #3}}
\newcommand{\Let}[4]{\ensuremath{\text{let } (#1 : #2) = #3 \text{ in } #4}}
\newcommand{\Forall}[3]{\ensuremath{\forall (#1 : #2) \text{ . } #3}}
\newcommand{\Exists}[3]{\ensuremath{\exists (#1 : #2) \text{ . } #3}}
\newcommand{\fAnd}[2]{\ensuremath{#1 \text{ \AndSymbol{} } #2}}
\newcommand{\fOr}[2]{\ensuremath{#1 \text{ \OrSymbol{} } #2}}
\newcommand{\fNot}[1]{\ensuremath{\text{\NotSymbol{} } #1}}
%\newcommand{\If}[3]{\ensuremath{\text{if } #1 \text{ then } #2 \text{ else } #3}}
\newcommand{\Add}[2]{\ensuremath{#1 \text{ \AddSymbol{} } #2}}
\newcommand{\Mul}[2]{\ensuremath{#1 \text{ \MulSymbol{} } #2}}
\newcommand{\Eq}[2]{\ensuremath{#1 \text{ \EqSymbol{} } #2}}
\newcommand{\Neq}[2]{\ensuremath{#1 \text{ \NeqSymbol{} } #2}}
\newcommand{\Leq}[2]{\ensuremath{#1 \text{ \LeqSymbol{} } #2}}
\newcommand{\Geq}[2]{\ensuremath{#1 \text{ \GeqSymbol{} } #2}}
\newcommand{\Le}[2]{\ensuremath{#1 \text{ \LeSymbol{} } #2}}
\newcommand{\Ge}[2]{\ensuremath{#1 \text{ \GeSymbol{} } #2}}
\newcommand{\Seq}[2]{\ensuremath{[#1, ..., #2]}}
\newcommand{\elReal}{\ensuremath{r}}
\newcommand{\elNat}{\ensuremath{i}}
\newcommand{\elBool}{\ensuremath{b}}
\newcommand{\At}[2]{\ensuremath{#1 \text{ \AtSymbol{} } #2}}
%\newcommand{\hLam}[3]{\ensuremath{\text{lam } (#1 : #2) \text{ . } #3}}


% contexts
\newcommand{\polCtx}{P}
\newcommand{\forallPol}{+}
\newcommand{\existsPol}{-}
\newcommand{\hNetCtx}{N}
\newcommand{\hVarCtx}{\Gamma}
\newcommand{\hRandCtx}{Q}
\newcommand{\lNetCtx}{M}
\newcommand{\lInputVarCtx}{I}
\newcommand{\lOutputVarCtx}{O}
\newcommand{\semCtx}{\hNetCtx, \hRandCtx, \hVarCtx}

% types

\newcommand{\hTypeRel}[3]{#1 \Vdash #2 : #3}
\newcommand{\hcTypeRel}[2]{\hTypeRel{\Xi,\Delta}{#1}{#2}}
\newcommand{\hcNetCtx}{\Xi}
\newcommand{\hcVarCtx}{\Delta}
\newcommand{\haTypeRel}{\hcTypeRel{e}{\tau}}

\newcommand{\lTypeRel}[2]{#1 \Vdash #2}
\newcommand{\laTypeRel}{\lTypeRel{\lNetCtx}{e}}
\newcommand{\cTypeRel}{\lTypeRel{\Xi}{w}}

%grammar
%\newcommand{\grammarItem}[1]{\langle \textit{#1} \, \rangle}
\newcommand{\grammarItem}[1]{#1}
%\newcommand{\typeClass}{\grammarItem{type}}
\newcommand{\typeClass}{\grammarItem{\tau}}
%\newcommand{\exprClass}{\grammarItem{expr}}
\newcommand{\exprClass}{\grammarItem{e}}
\newcommand{\opClass}{\grammarItem{op}}
\newcommand{\identClass}{\grammarItem{x}}
\newcommand{\netClass}{\grammarItem{f}}

\newcommand{\progClass}{\grammarItem{prog}}
\newcommand{\queryClass}{\grammarItem{query}}
\newcommand{\arithClass}{\grammarItem{arith}}
\newcommand{\compareClass}{\grammarItem{comp}}
\newcommand{\conjClass}{\grammarItem{conj}}
\newcommand{\inputVarClass}{\grammarItem{inputVar}}
\newcommand{\outputVarClass}{\grammarItem{outputVar}}

% semantics

\newcommand{\hSem}[2]{{\llbracket #1 \rrbracket}^{#2}}
\newcommand{\hsSem}[1]{\hSem{#1}{\hVarCtx}}

\newcommand{\lCtxFun}{\gamma}
\newcommand{\lNetCtxSem}[3]{\lSemBraces{#1}^{#2,#3}}

\newcommand{\lSemBraces}[1]{\langle \! \langle #1 \rangle \! \rangle}
\newcommand{\lSem}[2]{{\lSemBraces{#1}}^{#2}}
\newcommand{\lsSem}[1]{\lSem{#1}{}}

\newcommand{\semSpace}{\qquad\qquad}

%these macros are for LJ sequent calculus


%% Some basic symbols
\DeclareMathSymbol{\Mu}{\mathalpha}{operators}{"4D}
\newcommand*{\SLASH}{\char`\\}

%%%%%%%% Arrows %%%%%%%%
%\usetikzlibrary{arrows}
%
%\newdimen{\ArrowLength}
%\newdimen{\ArrowHeight}
%%% Extensible arrow of the shape ->>
%\DeclareDocumentCommand{\xtwoheadrightarrow}{O{} m O{10pt}}{%
%	\setlength{\ArrowLength}{\maxof{\maxof{\widthof{$#1$}}{\widthof{$#2$}}}{#3}}%
%	\tikz[minimum height=0ex,baseline]{%
%		\draw[every label]
%		node [anchor=base,inner sep=0pt] (a) {\phantom{a}}
%		node [right=\ArrowLength of a,inner sep=0pt] (b) {} ;
%		\draw [-{To[]To[]},shorten >=2pt] (a.center)
%		-- node[above]{$#2$} node[below]{$#1$} (b.center);
%	}%
%}

%% Typset macro
\newcommand*{\macro}[1]{\mbox{\texttt{\SLASH{}#1}}}

%%%% Checking for empty argument with xparse
\ExplSyntaxOn
\DeclareExpandableDocumentCommand{\IfNoValueOrEmptyTF}{mmm}
{
	\IfNoValueTF{#1}{#2}
	{
		\tl_if_empty:nTF {#1} {#2} {#3}
	}
}
\ExplSyntaxOff

% For internal use only!
% Typeset a symbol with indices.
% \limSym{\BooleanTrue}{sym} forces sym to be small with indices on the side
% (textstyle), while \limSym{\BooleanFalse}{sym} typesets sym depending on
% the surrounding style.
% The two optional arguments are the lower and uppper index, respectively.
\DeclareDocumentCommand{\limSym}{m m o o}{%
	\IfBooleanT{#1}{\textstyle}%
	#2%
	\IfNoValueOrEmptyTF{#3}{}{_{#3}}%
	\IfValueT{#4}{^{#4}}%
}


%%%%% General macros %%%%%
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\brak}{[}{]}
\newcommand*{\bparens}[1]{\parens[\big]{#1}}
\DeclarePairedDelimiterX{\wparens}[1]{(}{)}{\, #1 \,}
\DeclarePairedDelimiterX{\wparensR}[1]{(}{)}{\hskip0.05em #1 \hskip0.21em}

%%%%% standard notations %%%%%
\newcommand*{\restr}[2]{{#1|}_{#2}}
\DeclarePairedDelimiter{\card}{|}{|}
\newcommand*{\coloncolonequals}{\Coloneqq}
\newcommand*{\colonequals}{\coloneqq}
\DeclarePairedDelimiter{\set}{\{}{\}}
\DeclarePairedDelimiterX{\setDef}[2]{\{}{\}}{#1 \; \delimsize| \; #2}
\newcommand*{\setDefR}[2]{\left\{#1 \; \middle| \; #2\right\}}
\DeclarePairedDelimiter{\sPair}{(}{)}
\DeclarePairedDelimiterXPP{\pow}[1]{\mathcal{P}}{(}{)}{}{#1}
\newcommand*{\from}{\colon}
\newcommand*{\injArr}[2]{#1 \hookrightarrow #2}
\newcommand*{\natTo}{\Rightarrow}
\newcommand*{\EMPTY}{\varnothing}
\newcommand*{\lub}{\sqcup}

%\newcommand*{\id}{\mathrm{id}}
%\newcommand*{\Id}{\mathrm{Id}}
\newcommand*{\comp}{\mathbin{\circ}}
\DeclareDocumentCommand{\Coprod}{s o o}{%
	\limSym{#1}{\coprod}[#2][#3]%
}
\DeclarePairedDelimiter{\copair}{[}{]}
\DeclarePairedDelimiter{\pair}{\langle}{\rangle}
\newcommand*{\inj}{\kappa}
\newcommand*{\quot}[2]{{#1}/\!{\scriptstyle #2}}
\DeclareMathOperator{\obj}{obj}
\DeclareMathOperator{\supp}{supp}

\newcommand*{\lists}[1]{#1^{\ast}}

%% Defines a macro \app, which can be passed a comma-separated list.
%% The interpretation is that \app{f,a,b,c,d} represents the application
%% of f on the arguments a, b, c, d.
%% The macro then type-sets this application accordingly.
\ExplSyntaxOn

\tl_new:N \l_xyz_tmp_tl
\NewDocumentCommand{\app}{ m }
{
	\seq_set_from_clist:Nn \l_xyz_input_seq { #1 }
	\seq_pop_left:NN \l_xyz_input_seq \l_xyz_tmp_tl
	\l_xyz_tmp_tl
	\seq_map_inline:Nn \l_xyz_input_seq
	{
		\, ##1
	}
	% \clist_map_inline:nn { #1 } { \, ##1 }
}

\ExplSyntaxOff

%%%%% some basic sets %%%%%
\newcommand*{\N}{\mathbb{N}}
\newcommand*{\Z}{\mathbb{Z}}
\newcommand*{\Q}{\mathbb{Q}}
\newcommand*{\R}{\mathbb{R}}

%%%%% some categories (in bold font) %%%%
%\newcommand*{\Cat}[1]{\mathbf{#1}}
\newcommand*{\SetC}{\Cat{Set}}
\newcommand*{\Ord}{\Cat{Ord}}
\newcommand*{\CatDescr}[2]{
	\begin{cases}
		\text{objects:} & #1 \\
		\text{morphisms:} & #2
	\end{cases}
}
\newcommand*{\Rel}{\mathrm{Rel}}
\newcommand*{\op}[1]{#1^{\mathrm{op}}}
\newcommand*{\TCat}{\Cat{E}}
\newcommand*{\BCat}{\Cat{B}}
\DeclarePairedDelimiterXPP{\Hom}[3]{\mathrm{Hom}_{#1}}{(}{)}{}{#2,#3}

%% Typesetting adjoint correspondence with optional labels
\newcommand*{\adjointLine}{\hhline{===}}
\newcommand*{\adjointLineLab}{\hhline{====}}

% Usage:
% First argument is arrow (default: \longrightarrow)
% Second argument is distance between fields
% Fields:
% [Name of morphism] & [Domain] & [Codomain] & [Label] & [Label beyond horizontal line]
\DeclareDocumentEnvironment{adjunction}{ D(){\longrightarrow{}} O{1.8} }{
	\begingroup
	\renewcommand*{\arraystretch}{#2}
	\begin{array}{rr @{ \; #1 \, } l l@{\hskip 0.3cm} l}
	}{
	\end{array}
	\endgroup
}

%%% Kleisli categories
% Kleisli morphisms
\DeclareDocumentCommand{\klTo}{}{%
	\setlength{\ArrowLength}{\widthof{$\to$}}%
	\setlength{\ArrowHeight}{\heightof{$\to$}}%
	\tikz[minimum height=0ex,baseline]{%
		\draw[every label]
		node [anchor=base,inner sep=0pt] (a) {\phantom{a}}
		node [right=\ArrowLength of a,inner sep=0pt] (b) {} ;
		\draw [-{To[]},shorten >=2pt]
		(a.center) --
		node[left=-0.01\ArrowLength,draw,circle,minimum size=0.8\ArrowHeight,inner sep=0pt] {}
		(b.center);
	}%
}

% Kleisli composition
\newcommand*{\klComp}{\circledcirc}
% Kleisli category
\newcommand*{\klCat}[1]{\mathit{Kl}_{#1}}


%% Type setting binders
\newcommand*{\bind}[2]{#1 #2. \,}

%% Higher-order terms
\DeclareDocumentCommand{\typed}{ O{\Gamma} m m }{%
	#1 \vdash #2 : #3%
}
\DeclareDocumentCommand{\guarded}{ O{\Gamma} m m }{%
	#1 \vdash_{g} #2 : #3%
}
\newcommand*{\TSig}{\Sigma}
%\newcommand*{\TSig}{\Sigma_{\Types}}
\newcommand*{\PSig}{\Pi}
%\newcommand*{\PSig}{\Sigma_{\PropT}}
\newcommand*{\TSigExt}{\ext{\TSig}}
\newcommand*{\PSigExt}{\ext{\PSig}}
\newcommand*{\Terms}[1]{\Lambda^{-}_{#1}}
\newcommand*{\FixTerms}[1]{\Lambda_{#1}}
\newcommand*{\GuardedFOTerms}[1]{\Lambda^{G,1}_{#1}}
\newcommand*{\GuardedTerms}[1]{\Lambda^{G}_{#1}}
\newcommand*{\FOTerms}[1]{\Lambda^{1}_{#1}}
\newcommand*{\FOSimpleTerms}[1]{\Lambda^{-,1}_{#1}}


%% Types
\newcommand*{\BaseT}{\mathbb{B}}
\newcommand*{\Types}{\mathbb{T}}
\newcommand*{\PropT}{\mathbb{P}}
\newcommand*{\baseT}{\iota}
\newcommand*{\propT}{o}
\DeclareMathOperator{\ord}{ord}

%% Term constructors

\newcommand*{\Vars}{\mathrm{Var}}
\newcommand*{\lamNew}[1]{\bind{\lambda}{#1}}
% \fix has as an optional argument the variable that it should bind.
% If that variable is provided, then "\fix[x] M" is properly typeset
% as complex term.
\DeclareDocumentCommand{\fix}{ o }{%
	\IfNoValueTF{#1}{%
		\mathrm{fix}%
	}{%
		\bind{\mathrm{fix} \,}{#1}%
	}%
}

%% Reduction relations
\newcommand*{\reduce}{\longrightarrow}
\newcommand*{\reduceIter}{\xtwoheadrightarrow{}[15pt]}
\newcommand*{\reduceB}{\longrightarrow_{\beta}}
\newcommand*{\reduceF}{\longrightarrow_{\fix}}
\newcommand*{\alphaEq}{=}
\newcommand*{\conv}{\equiv}

%% Logical connectives
\newcommand*{\all}[1]{\bind{\forall}{#1}}
\newcommand*{\exist}[1]{\bind{\exists}{#1}}
\newcommand*{\conj}{\wedge}
% Typeset conjunction with indices. \Conj* makes
% the conjunction small with indices on the side (textstyle).
% The two optional arguments are the lower and uppper index, respectively.
\DeclareDocumentCommand{\Conj}{s o o}{%
	\limSym{#1}{\bigwedge}[#2][#3]%
}


\newcommand*{\disj}{\vee}
\newcommand*{\impl}{\Rightarrow}

%% Handling of signatures
% \DeclarePairedDelimiter{\sym}{|}{|}
\DeclareMathOperator{\ar}{ar}
\DeclarePairedDelimiter{\ext}{\llbracket}{\rrbracket}
\newcommand*{\Hterms}[1]{#1^{\ast}}
\newcommand*{\coterms}[1]{#1^{\infty}}
\newcommand*{\Subst}{\mathrm{Subst}}
\newcommand*{\coSubst}{\Subst^{\infty}}
\newcommand*{\substArr}{\triangleright}
% \newcommand*{\subst}[3]{#1 : #2 \substArr #3}
\newcommand*{\inC}{\mathrm{in}}
\newcommand*{\leaf}{\mathrm{leaf}}
\newcommand*{\node}{\mathrm{node}}
\newcommand*{\rootO}{\mathrm{root}}
\newcommand*{\HBase}{\mathcal{B}^{\ast}}
\newcommand*{\coHBase}{\mathcal{B}^{\infty}}
\newcommand*{\Interp}{\mathcal{I}}
% \newcommand*{\ProgOp}[1]{\Phi}
\DeclareDocumentCommand{\I}{ O{I} m }{%
	\restr{#1}{#2}%
}
% \DeclareDocumentCommand{\ProgOp}{ o m }{%
%   \IfNoValueTF{#1}{%
%     \Phi%
%   }{%
%     \Phi_{#1}%
%   }%
% }
\DeclareDocumentCommand{\ProgOp}{ m }{%
	\Phi_{#1}%
}
\DeclareDocumentCommand{\Model}{ o }{%
	\IfNoValueTF{#1}{%
		\mathcal{M}%
	}{%
		\mathcal{M}_{#1}%
	}%
}
% \newcommand*{\Pred}{\mathcal{L}}
\newcommand*{\CtxC}{\mathcal{C}}
\newcommand*{\ctxTo}{\hookrightarrow}
\newcommand*{\CupC}{\Cat{CUP}^P}
\newcommand*{\CupF}{\pi_{\mathrm{CUP}}}
\newcommand*{\FolC}{\Cat{iFOL}_{\later}^P}
\newcommand*{\FolF}{\pi_{\iFOLm}}
\newcommand*{\PredC}{\Cat{Pred}}
\newcommand*{\Arit}{\mathcal{C}}
\newcommand*{\predF}{\mathbb{P}}
\newcommand*{\reidx}[2][\ast]{#2^{#1}}
\newcommand*{\Fin}{\mathbf{1}}
%\newcommand*{\Nil}{\mathbf{0}}
\newcommand*{\predTop}{\top}
\newcommand*{\predImpl}{\mathrel{\Rightarrow}}
\newcommand*{\predCTop}{\dot{\top}}
\newcommand*{\predCImpl}{\mathrel{\dot{\Rightarrow}}}
\newcommand*{\predCConj}{\mathrel{\dot{\conj}}}
\newcommand*{\predCDisj}{\mathrel{\dot{\disj}}}
\DeclarePairedDelimiter{\sem}{\llbracket}{\rrbracket} % interpretation
\DeclarePairedDelimiterXPP{\foSem}[1]{}{\llbracket}{\rrbracket}{_1}{#1} % interpretation of FO terms
\DeclareDocumentCommand{\valid}{ m d() o m }{%
	#1%
	\IfNoValueTF{#2}{,#2}%
	\IfNoValueTF{#3}{,#3}%
	\vDash #4%
}

%% Interpretation of L√∂b
\newcommand*{\ch}[1]{\overline{#1}}
\newcommand*{\finChain}[1]{\overleftarrow{\mkern3mu#1}}
\newcommand*{\nextOp}{\mathrm{next}}
\newcommand*{\lob}{\mathrm{l}\ddot{\mathrm{o}}\mathrm{b}}
\newcommand*{\pConv}{\mathrm{conv}}

%% Formulas and programs
\newcommand*{\atoms}{\mathrm{At}}
\newcommand*{\foAt}{\atoms_1}
\newcommand*{\guardedAt}{\atoms^g_{\omega}}
\DeclareDocumentCommand{\simpleAt}{ o }{%
	\IfNoValueTF{#1}{%
		\atoms^s_{\omega}%
	}{%
		\atoms^s_{#1}%
	}%
}
\newcommand*{\foGuardedAt}{\atoms_1^g}
\newcommand*{\foSimpleAt}{\atoms_1^s}

\newcommand*{\forms}{\mathrm{Form}}
\newcommand*{\coforms}{\mathrm{Form}^{\infty}}
\newcommand*{\clause}[2][]{#1 \Rightarrow #2}
\DeclareMathOperator{\parity}{par}
\newcommand*{\binbox}{\mathbin{\Box}}

%%%% Rule label %%%%%
\newcommand*{\rulelabel}[1]{{\normalfont \textbf{(#1)}}}

%% L√∂b logic
\newcommand*{\Ctx}{\Cat{Ctx}}
\newcommand*{\iFOL}{\mathbf{iFOL}}
\DeclareMathOperator{\later}{\blacktriangleright}
\newcommand*{\iFOLm}{\mathbf{iFOL}_{\later}}

\newcommand*{\validForm}[2][\Xi,\Delta]{#1 \Vvdash  #2}
%\newcommand*{\validForm}[2][\Xi,\Delta]{#1 \vDash  #2}
%\newcommand*{\validFormR}[2][\Xi,\Delta]{#1 \Vvdash #2}


% Notation for provability in recursive logic:
% \infer(\Gamma)[\Delta]{\psi} means that \psi is provable in
% term context \Gamma under the assumption in \Delta.
% Note that \Gamma and \Delta are both optional.
\DeclareDocumentCommand{\inferFOL}{ D(){\Gamma} O{\Delta} m }{%
	\IfNoValueOrEmptyTF{#1}{%
		\IfNoValueOrEmptyTF{#2}{%
		}{%
			#2%
		}%
	}{%
		#1%
		\IfNoValueOrEmptyTF{#2}{%
		}{%
			\mid #2%
		}
	}%
	\vdash #3
}

% Takes a comma-separated list t1/x1,...,tn/xn and type sets corresponding substitution
% with the correct size for surrounding brackets and the intermediate slashes.
% Note that the foreach parser might choke on more complicated stuff like
% \scalerel{..}{..} or \vv{...}
\newcommand*{\subst}[1]{%
	\left[%
	\foreach \x / \y [remember=\x as \lastx (initially initial)] in {#1}%
	{\ifthenelse{\equal{\lastx}{initial}}{}{\!,} \left. \x \middle/ \y \right.}%
	\right]%
}

% Substitions without automatic scaling of inner slashes
\DeclarePairedDelimiterX{\ssubst}[2]{[}{]}{#1 \delimsize/ #2}

% Rules for L√∂b logic
\newcommand*{\Proj}{\rulelabel{Proj}}
\newcommand*{\Conv}{\rulelabel{Conv}}
\newcommand*{\Next}{\rulelabel{Next}}
\newcommand*{\FP}{\rulelabel{L√∂b}}
\newcommand*{\Mon}{\rulelabel{Mon}}
\newcommand*{\AllI}{\rulelabel{$\forall$-I}}
\newcommand*{\AllE}{\rulelabel{$\forall$-E}}
\newcommand*{\ExI}{\rulelabel{$\exists$-I}}
\newcommand*{\ExE}{\rulelabel{$\exists$-E}}
\newcommand*{\OrI}[1][]{\rulelabel{$\disj_{#1}$-I}}
\newcommand*{\OrE}{\rulelabel{$\disj$-E}}
\newcommand*{\AndI}{\rulelabel{$\conj$-I}}
\newcommand*{\AndE}[1][]{\rulelabel{$\conj_{#1}$-E}}
\newcommand*{\ImplI}{\rulelabel{$\to$-I}}
\newcommand*{\ImplE}{\rulelabel{$\to$-E}}
\newcommand*{\TopI}{\rulelabel{$\top$-I}}
\newcommand*{\BotE}{\rulelabel{$\bot$-E}}
\newcommand*{\Weak}{\rulelabel{Weak}}
\newcommand*{\Appl}{\rulelabel{Appl}}
\newcommand*{\MonL}{\rulelabel{Mon$_l$}}
\newcommand*{\LaterPresConjL}{\rulelabel{$\later$-Pres-$\conj_l$}}
\newcommand*{\LaterPresConjR}{\rulelabel{$\later$-Pres-$\conj_r$}}
\newcommand*{\LaterPresConjO}{\rulelabel{$\later$-Pres-$\conj_1$}}
\newcommand*{\LaterPresConjI}{\rulelabel{$\later$-Pres-$\conj_2$}}
\newcommand*{\LaterPresAll}{\rulelabel{$\later$-Pres-$\forall$}}
\newcommand*{\LaterPresAllL}{\rulelabel{$\later$-Pres-$\forall_l$}}
\newcommand*{\LaterPresAllR}{\rulelabel{$\later$-Pres-$\forall_r$}}
\newcommand*{\XRule}{\rulelabel{X}}
\newcommand*{\LaterPresXRule}{\rulelabel{$\later$-Pres-X}}
\newcommand*{\StarRule}[1][]{\rulelabel{$*{#1}$}}


%% From CUP to L√∂b
\newcommand*{\guard}[1]{\overline{#1}}

%% Notations in CUP

\newcommand*{\fixBeta}{{\textit{fix}\beta}}
\newcommand*{\fixBetaEq}{=_{\textit{fix}\beta}}
\DeclarePairedDelimiter{\guardCUP}{\langle}{\rangle}

\newcommand*{\UParrow}{\Longrightarrow}
\newcommand*{\UPBarrow}[1]{\xRightarrow{#1}}
\newcommand*{\CUParrow}{\looparrowright}
% sequent in Uniform Proof
% \sequentUP{<signature field>}{<program field>}{<invariant field>}{<succedent>}
\newcommand*{\sequentUP}[5]{#1 ; #2 ; #3 ; #4 \UParrow #5}
% sequent in Uniform Proof backchaining
% \sequentUP{<signature field>}{<program field>}{<invariant field>}{<backchaining>}{<succedent>}
\newcommand*{\sequentUPb}[6]{#1 ; #2 ; #3 ; #4 \UPBarrow{#5} #6}
% sequent in Coinductive Uniform Proof
% \sequentUP{<signature field>}{<program field>}{<succedent>}
\newcommand*{\sequentCUP}[3]{#1 ; #2 \CUParrow #3 }
% gaurded uniform proof entailment
\newcommand*{\sequentUPg}[4]{#1 ; #2 ; #3 \UParrow \guardCUP{#4} }
% sequent with default values
\DeclareDocumentCommand{\SequentUP}{ D(){\TSig} O{P} O{\Delta_A} O{\Delta_C} m }{%
	\sequentUP{#1}{#2}{#3}{#4}{#5}
}
\DeclareDocumentCommand{\SequentUPb}{ O{\TSig} O{P} O{\Delta_A} O{\Delta_C} m O{} }{%
	\sequentUPb{#1}{#2}{#3}{#4}{#5}{#6}
}
\DeclareDocumentCommand{\SequentUPg}{ D(){\TSig} O{P} O{\Delta} m }{%
	\sequentUPg{#1}{#2}{#3}{#4}
}
\DeclareDocumentCommand{\SequentCUP}{ O{\TSig} O{P} O{\varphi} }{%
	\sequentCUP{#1}{#2}{#3}
}

%% Notations in LJ

\newcommand*{\LJ}{\textbf{LJ}}
\newcommand*{\CLJ}{\textbf{CLJ}}
\newcommand*{\LK}{\textbf{LK}}

% sequent in (LJ + CO-FIX rule)
% \sequentCLJ{<theory asumptions field>}{<other guarded assumptions field>}{<non-guarded assumptions field>}{<succedent>}
\newcommand*{\ThAssumsEnv}{\Gamma_T}
\newcommand*{\GuardedAssumsEnv}{\Gamma_A}
\newcommand*{\CoindAssumsEnv}{\Gamma_C}
\newcommand*{\sequentCLJ}[2]{#1  \vdash #2}
%\DeclareDocumentCommand{\SequentCLJ}{ D(){\ThAssumsEnv} O{\GuardedAssumsEnv} O{\CoindAssumsEnv} m }{%
%	\sequentCLJ{#1}{#2}{#3}{#4}
%}
\DeclareDocumentCommand{\SequentCLJ}{ D(){\ThAssumsEnv} m }{%
	\sequentCLJ{#1}{#2}
}


\newcommand*{\LJArithL}{\rulelabel{Arith-L}}
\newcommand*{\LJArithR}{\rulelabel{Arith-R}}
\newcommand*{\LJAxiom}{\rulelabel{Axiom}}
\newcommand*{\LJCut}{\rulelabel{Cut}}
\newcommand*{\LJCtrL}{\rulelabel{C-L}}
\newcommand*{\LJCtrLT}{\rulelabel{CL-T}}
\newcommand*{\LJCtrR}{\rulelabel{C-R}}
\newcommand*{\LJWeakL}{\rulelabel{W-L}}
\newcommand*{\LJWeakLT}{\rulelabel{WL}}
\newcommand*{\LJWeakRT}{\rulelabel{WR}}
\newcommand*{\LJWeakR}{\rulelabel{W-R}}
\newcommand*{\LJExchLT}{\rulelabel{XL-T}}
\newcommand*{\LJCoFixRule}{\rulelabel{CO-FIX}}
\newcommand*{\LJConjL}{\rulelabel{$\conj$-L}}
%\newcommand*{\LJConjLG}{\rulelabel{$\conj$-L-G}}
\newcommand*{\LJConjR}{\rulelabel{$\conj$-R}}
\newcommand*{\LJDisjL}{\rulelabel{$\disj$-L}}
%\newcommand*{\LJDisjLG}{\rulelabel{$\disj$-L-G}}
\newcommand*{\LJDisjR}{\rulelabel{$\disj$-R}}
\newcommand*{\LJAllL}{\rulelabel{$\forall$-L}}
%\newcommand*{\LJAllLG}{\rulelabel{$\forall$-L-G}}
\newcommand*{\LJAllR}{\rulelabel{$\forall$-R}}
\newcommand*{\LJExL}{\rulelabel{$\exists$-L}}
%\newcommand*{\LJExLG}{\rulelabel{$\exists$-L-G}}
\newcommand*{\LJExR}{\rulelabel{$\exists$-R}}
\newcommand*{\LJImplL}{\rulelabel{$\to$-L}}
%\newcommand*{\LJImplLG}{\rulelabel{$\to$-L-G}}
\newcommand*{\LJImplR}{\rulelabel{$\to$-R}}
\newcommand*{\LJNegR}{\rulelabel{$\neg$-R}}
\newcommand*{\LJNegL}{\rulelabel{$\neg$-L}}




% Frequently used contants
\newcommand*{\scons}{\mathrm{scons}}
\newcommand*{\fromP}{\mathbf{from}}
\newcommand*{\fromFun}{s_\mathrm{fr}}
\newcommand*{\zeros}[1]{\mathrm{zeros}}
\newcommand*{\nat}{\mathbf{nat}}
\newcommand*{\clNatZ}{\kappa_{\nat 0}}
\newcommand*{\clNatS}{\kappa_{\nat s}}
\newcommand*{\natModel}{\mathcal{N}}
\newcommand*{\stream}{\mathbf{stream}}
\newcommand*{\streamModel}{\mathcal{S}}
\newcommand*{\fib}{\mathbf{fib}}
\newcommand*{\plusFun}{\mathrm{plus}}
\newcommand*{\resource}{\mathbf{resource}}
\newcommand*{\signal}{\mathbf{signal}}
\newcommand*{\novalue}{\mathrm{novalue}}
\newcommand*{\get}{\mathrm{get}}
\newcommand*{\inP}{\mathrm{in}}
\newcommand*{\varP}{\mathbf{var}}
\newcommand*{\findP}{\mathbf{find}}
\newcommand*{\typedP}{\mathbf{typed}}
\newcommand*{\appP}{\mathrm{app}}
\newcommand*{\eq}{\mathbf{eq}}
\newcommand*{\eqBase}{\mathrm{i}}
\newcommand*{\odd}{\mathrm{odd}}
\newcommand*{\even}{\mathrm{even}}

\newcommand*{\sconsFunc}[2]{\scons \ #1\ #2}
\newcommand*{\fromPred}[2]{\fromP \ #1\ #2}
\newcommand*{\zerosPred}[1]{\zeros\ #1}
\DeclareDocumentCommand{\fromstream}{ m }{
	\IfNoValueOrEmptyTF{#1}
	{
		\textit{fr\_str}
	}
	{
		\textit{fr\_str}\ #1
	}
}


% Phrase short cuts
\newcommand*{\Lob}{L\"{o}b~}
\newcommand*{\cofohc}{\textit{co-fohc}}
\newcommand*{\cohohc}{\textit{co-hohc}}
\newcommand*{\cofohh}{\textit{co-fohh}}
\newcommand*{\cohohh}{\textit{co-hohh}}
\newcommand*{\fohc}{\textit{fohc}}
\newcommand*{\hohc}{\textit{hohc}}
\newcommand*{\fohh}{\textit{fohh}}
\newcommand*{\hohh}{\textit{hohh}}
\newcommand*{\ClauseHead}[1][]{\textit{head }#1}
\newcommand*{\ClauseBody}[1][]{\textit{body }#1}
\DeclareDocumentCommand{\CoindGoal}{s}{%
	\IfBooleanTF{#1}{coinduction goals}{coinduction goal}\xspace%
}


% Rule names
% Uniform Proof rules
\newcommand*{\TopR}{{\top} R}
\newcommand*{\TopL}{{\top} L}
\newcommand*{\ExistsR}{{\exists} R}
\newcommand*{\OrR}{{\disj} R}
\newcommand*{\AndR}{{\conj} R}
\newcommand*{\AndL}{{\conj} L}
\newcommand*{\AllR}{\forall R}
\newcommand*{\AllL}{\forall L}
\newcommand*{\ImplL}{{\impl}L}
\newcommand*{\ImplR}{{\impl}R}
\newcommand*{\Init}{\textsc{initial}}
\newcommand*{\Dec}{\textsc{decide}}
%  CUP rules
\newcommand*{\Cofix}{\textsc{co-fix}}
\newcommand*{\Cut}{\textsc{cut}}
\newcommand*{\AllRG}{{\forall} R \guardCUP{}}
\newcommand*{\ImplRG}{{\impl} R \guardCUP{}}
\newcommand*{\ConjRG}{{\conj} R \guardCUP{}}
\newcommand*{\DecG}{\textsc{decide} \guardCUP{}}

%% Notations in heuristics
% see also: Frequently used contants
% empty list in tree language
\newcommand*{\rewTreeRoot}{\epsilon}
% Free Var
\newcommand*{\FVar}[1]{\mathrm{FVar}(#1)}
% Function symbols in atom
\newcommand*{\FunSym}[1]{\TSig(#1)}
% unifing relation
\newcommand*{\unifies}[1][\sigma]{\sim_{#1}}
% term matching relation
\newcommand*{\matches}[1][\sigma]{\prec_{#1}}
% SLD reduction
\newcommand*{\sldRed}{\rightsquigarrow}
% rewriting reduction
\newcommand*{\rewRed}{\rightarrowtail}
% rewriting tree transition
\newcommand*{\rewTreeTran}[1][\theta]{\stackrel{#1}{\leadsto}}
% loop
\DeclarePairedDelimiter{\loopHeu}{\langle}{\rangle}
\DeclarePairedDelimiter{\critPairHeu}{\langle}{\rangle}
\DeclarePairedDelimiter{\critTripHeu}{\langle}{\rangle}
% apply substitution #1 to term #2
\newcommand*{\applSubst}[2]{#1(#2)}
% edge of rewriting tree T(w \cdot i)
\newcommand*{\rewTreeEdge}[3][T]{#1(#2 \cdot #3)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uniform-corec"
%%% ispell-local-dictionary: "british"
%%% End:
